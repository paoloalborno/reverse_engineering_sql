<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Riassunto del Repository: SQL Reverse Engineering Toolkit</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            width: 80%;
            margin: auto;
            overflow: hidden;
            padding: 2rem 0;
        }
        .page-section {
            background: #fff;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .section-title {
            text-align: center;
            margin-bottom: 2rem;
        }
        .summary-container {
            margin-bottom: 1.5rem;
        }
        .summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 1rem;
            background-color: #f0f0f0;
            border-radius: 8px;
            transition: background-color 0.3s;
        }
        .summary-header:hover {
            background-color: #e0e0e0;
        }
        .summary-content {
            display: none;
            padding: 1.5rem;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 8px 8px;
            background-color: #fafafa;
        }
        .summary-content pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 1em;
            border-radius: 5px;
            font-family: 'Courier New', Courier, monospace;
        }
        .text-justify {
            text-align: justify;
        }
        h2 {
            margin: 0;
            font-size: 1.5rem;
            color: #333;
        }
        h4 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #007BFF;
            padding-bottom: 0.5rem;
            color: #007BFF;
        }
        h5 {
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            color: #333;
        }
        p, li {
            font-size: 1rem;
        }
        ul {
            padding-left: 20px;
        }
    </style>
</head>
<body>

    <main class="container">
        <section class="page-section">
            <h1 class="section-title">Analisi del Repository: SQL Reverse Engineering Toolkit</h1>

            <!-- Panoramica Unificata -->
            <div class="summary-container">
                <div class="summary-header">
                    <h2>Panoramica del Progetto e Analisi dei Moduli</h2>
                    <i class="fas fa-chevron-down"></i>
                </div>
                <div class="summary-content">
                    <div class="text-justify">
                        <p>
                            Questo repository contiene un "SQL Reverse Engineering Toolkit", un'applicazione a riga di comando progettata per analizzare e visualizzare la data lineage in un database MySQL. Lo strumento estrae le definizioni delle tabelle e delle stored procedure, le analizza per identificare le dipendenze (quali procedure leggono o scrivono su quali tabelle) e genera un grafo interattivo delle dipendenze. È uno strumento ideale per comprendere la logica di database complessi, effettuare il refactoring di codice legacy e documentare i flussi di dati.
                        </p>

                        <h4>Architettura Generale</h4>
                        <p>
                            Il sistema è suddiviso in componenti chiave, ognuno con una responsabilità specifica, seguendo il principio della separazione delle preoccupazioni (Separation of Concerns). Questa architettura modulare rende il codice più facile da comprendere, manutenere ed estendere.
                            <ul>
                                <li><strong>`parser.py`:</strong> Fornisce utilità leggere per analizzare istruzioni SQL (DDL/DML) ed estrarre una data lineage semplificata.</li>
                                <li><strong>`extractor.py`:</strong> Un toolkit di sola lettura per estrarre lo schema del database (CREATE TABLE) e le definizioni delle stored procedure da un database MySQL e salvarle come file SQL.</li>
                                <li><strong>`graph_utils.py`:</strong> Costruisce e visualizza il grafo delle dipendenze utilizzando `networkx` e `graphviz`.</li>
                                <li><strong>`materializer.py`:</strong> Gestisce la creazione e la sostituzione di viste di database (materialized views) per riassumere dati.</li>
                                <li><strong>`cli.py`:</strong> Fornisce un'interfaccia a riga di comando per orchestrare l'intero processo, collegando l'estrattore, il parser e il visualizzatore di grafi.</li>
                            </ul>
                        </p>

                        <h4>Lezioni Apprese e Best Practice</h4>
                        <p>
                            Una delle principali lezioni di questo progetto è l'importanza della <strong>modularità</strong>. Suddividere l'applicazione in moduli con responsabilità chiare (`extractor`, `parser`, `graph_utils`) migliora notevolmente la manutenibilità. Un'altra best practice è la <strong>gestione della configurazione</strong> tramite variabili d'ambiente (file `.env`), che separa la configurazione dal codice e migliora la sicurezza.
                        </p>

                        <!-- Inizio Documentazione Moduli -->

                        <h4>`parser.py` - Analisi e Parsing SQL</h4>
                        <p>
                            Il modulo `parser.py` è il cuore dell'analisi del lignaggio dei dati. La sua responsabilità è analizzare il testo delle istruzioni SQL (come `CREATE PROCEDURE`) per estrarre quali tabelle vengono lette e quali vengono scritte. Questo approccio è intenzionalmente leggero e non tenta di essere un parser SQL completo, ma è sufficiente per il reverse-engineering delle stored procedure.
                        </p>
                        <h5>Funzioni Chiave e Logica</h5>
                        <p>
                            La funzione principale è `parse_lineage`, che orchestra l'intero processo di analisi. Prima normalizza l'SQL per renderlo più facile da analizzare, poi estrae le tabelle di lettura e scrittura.
                        </p>
                        <pre><code class="language-python">
# parser.py
def parse_lineage(sql_text: str) -> Dict[str, List[str]]:
    """
        Objective: High-level API. Given raw SQL text (e.g., from SHOW CREATE PROCEDURE),
        return a dictionary with:
            {"reads": [...], "writes": [...]}
    """
    return {
        "reads": extract_read_tables(sql_text),
        "writes": extract_write_tables(sql_text)
    }
                        </code></pre>
                        <p>
                            Per l'estrazione vera e propria, il modulo si affida a espressioni regolari (regex). Questo è un ottimo esempio di come le regex possano essere utilizzate per estrarre informazioni strutturate da testo non strutturato.
                        </p>
                        <pre><code class="language-python">
# parser.py
# Constants for SQL pattern matching
READ_TABLE_PATTERN = r"(?:from|join)\s+([a-zA-Z0-9_]+)"
WRITE_TABLE_PATTERNS = [
    r"insert\s+into\s+([a-zA-Z0-9_]+)",
    r"update\s+([a-zA-Z0-9_]+)",
    r"delete\s+from\s+([a-zA-Z0-9_]+)"
]
                        </code></pre>
                        <h5>Lezioni Apprese e Best Practice</h5>
                        <p>
                            La lezione principale di questo modulo è che non sempre è necessaria una soluzione complessa per un problema apparentemente complesso. Invece di implementare un parser SQL completo, che sarebbe un'impresa enorme, il progetto utilizza espressioni regolari mirate per estrarre solo le informazioni necessarie. Questo è un ottimo esempio di pragmatismo ingegneristico.
                        </p>

                        <h4>`extractor.py` - Estrazione da Database</h4>
                        <p>
                            Il modulo `extractor.py` è responsabile della connessione al database MySQL e dell'estrazione delle informazioni grezze. Questo modulo è progettato per essere di sola lettura, garantendo che non modifichi mai i dati o lo schema del database. La sua responsabilità principale è interrogare i metadati del database (`information_schema`) e utilizzare comandi come `SHOW CREATE TABLE` per ottenere il DDL (Data Definition Language).
                        </p>
                        <h5>Classi e Metodi Chiave</h5>
                        <p>
                            La classe `DatabaseExtractor` orchestra il processo di estrazione. Utilizza un `DatabaseConnection` per gestire la connessione al database. Il metodo `dump_schema_and_routines` è il punto di ingresso principale, che coordina l'estrazione di tabelle e routine.
                        </p>
                        <pre><code class="language-python">
# extractor.py
def dump_schema_and_routines(cfg: dict, output_path: str) -> dict:
    """
        Objective: Orchestrate the extraction of table DDLs and routine definitions, save them to files,
        and create a dump_meta.json describing what was saved.
        The function is read-only and safe.
        Returns a meta-dictionary with tables and routines.
    """
    cfg = cfg or get_db_cfg()
    db_connection = DatabaseConnection(cfg)
    extractor = DatabaseExtractor(db_connection)
    # ... (omitted for brevity) ...
                        </code></pre>
                        <p>
                            Una best practice importante qui è l'uso di un context manager per la connessione al database, che garantisce che la connessione venga sempre chiusa correttamente, anche in caso di errori.
                        </p>
                        <pre><code class="language-python">
# extractor.py
class DatabaseConnection:
    @contextmanager
    def get_connection(self):
        """Context manager for database connections."""
        conn = None
        try:
            conn = mysql.connector.connect(...)
            yield conn
        finally:
            if conn:
                conn.close()
                        </code></pre>
                        <h5>Lezioni Apprese e Best Practice</h5>
                        <p>
                            La lezione chiave di questo modulo è l'importanza di isolare le interazioni con il database in un unico componente. Questo rende il resto dell'applicazione indipendente dai dettagli specifici del database. Inoltre, l'approccio di sola lettura (`read-only`) è una best practice fondamentale per la sicurezza quando si lavora con sistemi di produzione.
                        </p>

                        <h4>`graph_utils.py` - Visualizzazione del Lineage</h4>
                        <p>
                            Il modulo `graph_utils.py` è responsabile della visualizzazione della data lineage. Prende i dati di lignaggio analizzati (dal `parser.py`) e li trasforma in un grafo di dipendenze visivo. Questo è fondamentale per rendere le complesse relazioni tra tabelle e procedure immediatamente comprensibili.
                        </p>
                        <h5>Funzioni Chiave e Logica</h5>
                        <p>
                            La funzione `build_graph` utilizza la libreria `networkx` per costruire un grafo diretto (`DiGraph`) dai dati di lignaggio. Ogni tabella e procedura diventa un nodo nel grafo, e le relazioni di lettura/scrittura diventano archi (edges).
                        </p>
                        <pre><code class="language-python">
# graph_utils.py
def build_graph(lineage: dict):
    nx_graph = nx.DiGraph()
    for procedure, procedure_data in lineage['procedures'].items():
        nx_graph.add_node(procedure, type="procedure")
        for table in procedure_data['writes']:
            nx_graph.add_node(table, type='table')
            nx_graph.add_edge(procedure, table, relation='writes', color="red", action="writes")
        for table in procedure_data['reads']:
            nx_graph.add_node(table, type='table')
            nx_graph.add_edge(table, procedure, relation='reads', color="blue", action="read by")
    return nx_graph
                        </code></pre>
                        <p>
                            Una volta costruito il grafo, la funzione `export_graphviz` utilizza la libreria `graphviz` per renderlo in un formato di immagine (come PNG).
                        </p>
                        <h5>Lezioni Apprese e Best Practice</h5>
                        <p>
                            La lezione principale di questo modulo è il potere della visualizzazione. I dati di lignaggio grezzi sono difficili da interpretare. Trasformandoli in un grafo, le dipendenze diventano immediatamente evidenti.
                        </p>

                        <h4>`materializer.py` - Creazione di Viste Materializzate</h4>
                        <p>
                            Il modulo `materializer.py` è responsabile della creazione delle viste nel database. Le viste sono query SQL predefinite utilizzate per creare sommari di dati di alto livello.
                        </p>
                        <h5>Funzioni Chiave e Logica</h5>
                        <p>
                            Il modulo definisce le viste come stringhe SQL in un dizionario, `VIEW_DEFINITIONS`. La funzione `materialize_all` orchestra il processo.
                        </p>
                        <pre><code class="language-python">
# materializer.py
def materialize_all():
    """Create or replace all materialized views."""
    db_connection = DatabaseConnection(get_db_cfg())
    create_views_from_definitions(db_connection, VIEW_DEFINITIONS)
                        </code></pre>
                        <h5>Lezioni Apprese e Best Practice</h5>
                        <p>
                            L'uso delle viste per semplificare query complesse e pre-aggregare i dati è un modello comune nel data warehousing. Centralizzare le definizioni in un dizionario è una best practice per la manutenibilità.
                        </p>

                        <h4>`cli.py` - Interfaccia a Riga di Comando</h4>
                        <p>
                            Il modulo `cli.py` è il punto di ingresso dell'applicazione. Fornisce un'interfaccia a riga di comando (CLI) che lega insieme tutti gli altri componenti.
                        </p>
                        <h5>Funzioni Chiave e Logica</h5>
                        <p>
                            La funzione `main` utilizza `argparse` per definire i comandi (`extract`, `parse`, `materialize`, `all`).
                        </p>
                        <pre><code class="language-python">
# cli.py
def main():
    parser = argparse.ArgumentParser(description="Reverse Engineering Toolkit CLI")
    parser.add_argument("command", choices=["extract", "parse", "materialize", "all"], help="Command to run...")
    args = parser.parse_args()
    # ...
                        </code></pre>
                        <h5>Lezioni Apprese e Best Practice</h5>
                        <p>
                            Costruire una CLI ben strutturata con `argparse`, una classe di configurazione (`CLIConfig`), e funzioni "runner" separate per ogni comando è una best practice che rende il codice facile da usare e da estendere.
                        </p>

                    </div>
                </div>
            </div>
        </section>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const headers = document.querySelectorAll('.summary-header');
            headers.forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const icon = header.querySelector('i');
                    const isHidden = content.style.display === 'none' || content.style.display === '';

                    content.style.display = isHidden ? 'block' : 'none';
                    icon.classList.toggle('fa-chevron-down', !isHidden);
                    icon.classList.toggle('fa-chevron-up', isHidden);
                });
            });
        });
    </script>
</body>
</html>